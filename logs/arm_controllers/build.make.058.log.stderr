[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:[m[K In member function â€˜[01m[Kvirtual void arm_controllers::velocity_controller::update(const ros::Time&, const ros::Duration&)[m[Kâ€™:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:23:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator*[m[Kâ€™ (operand types are â€˜[01m[KKDL::Jacobian[m[Kâ€™ and â€˜[01m[KKDL::JntArray[m[Kâ€™)
  326 |             Vd_ = [32m[KJd_[m[K [01;31m[K*[m[K [34m[Kqd_dot_[m[K;
      |                   [32m[K~~~[m[K [01;31m[K^[m[K [34m[K~~~~~~~[m[K
      |                   [32m[K|[m[K     [34m[K|[m[K
      |                   [32m[K|[m[K     [34m[KKDL::JntArray[m[K
      |                   [32m[KKDL::Jacobian[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/frames.inl:83:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector KDL::operator*(const KDL::Vector&, double)[m[Kâ€™
   83 | Vector [01;36m[Koperator[m[K *(const Vector& lhs,double rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:83:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
   83 | Vector operator *([01;36m[Kconst Vector& lhs[m[K,double rhs)
      |                   [01;36m[K~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:92:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector KDL::operator*(double, const KDL::Vector&)[m[Kâ€™
   92 | Vector [01;36m[Koperator[m[K *(double lhs,const Vector& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:92:26:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
   92 | Vector operator *([01;36m[Kdouble lhs[m[K,const Vector& rhs)
      |                   [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:110:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector KDL::operator*(const KDL::Vector&, const KDL::Vector&)[m[Kâ€™
  110 | Vector [01;36m[Koperator[m[K *(const Vector & lhs,const Vector& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:110:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
  110 | Vector operator *([01;36m[Kconst Vector & lhs[m[K,const Vector& rhs)
      |                   [01;36m[K~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:242:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator*(const KDL::Wrench&, double)[m[Kâ€™
  242 | Wrench [01;36m[Koperator[m[K*(const Wrench& lhs,double rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:242:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
  242 | Wrench operator*([01;36m[Kconst Wrench& lhs[m[K,double rhs)
      |                  [01;36m[K~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:247:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator*(double, const KDL::Wrench&)[m[Kâ€™
  247 | Wrench [01;36m[Koperator[m[K*(double lhs,const Wrench& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:247:25:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  247 | Wrench operator*([01;36m[Kdouble lhs[m[K,const Wrench& rhs)
      |                  [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:345:7:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Twist KDL::operator*(const KDL::Twist&, double)[m[Kâ€™
  345 | Twist [01;36m[Koperator[m[K*(const Twist& lhs,double rhs)
      |       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:345:30:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  345 | Twist operator*([01;36m[Kconst Twist& lhs[m[K,double rhs)
      |                 [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:350:7:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Twist KDL::operator*(double, const KDL::Twist&)[m[Kâ€™
  350 | Twist [01;36m[Koperator[m[K*(double lhs,const Twist& rhs)
      |       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:350:24:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  350 | Twist operator*([01;36m[Kdouble lhs[m[K,const Twist& rhs)
      |                 [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:379:7:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Twist KDL::operator*(const KDL::Twist&, const KDL::Twist&)[m[Kâ€™
  379 | Twist [01;36m[Koperator[m[K*(const Twist& lhs,const Twist& rhs)
      |       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:379:30:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  379 | Twist operator*([01;36m[Kconst Twist& lhs[m[K,const Twist& rhs)
      |                 [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:383:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator*(const KDL::Twist&, const KDL::Wrench&)[m[Kâ€™
  383 | Wrench [01;36m[Koperator[m[K*(const Twist& lhs,const Wrench& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:383:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  383 | Wrench operator*([01;36m[Kconst Twist& lhs[m[K,const Wrench& rhs)
      |                  [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:406:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Frame KDL::operator*(const KDL::Frame&, const KDL::Frame&)[m[Kâ€™
  406 |  Frame [01;36m[Koperator[m[K *(const Frame& lhs,const Frame& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:406:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
  406 |  Frame operator *([01;36m[Kconst Frame& lhs[m[K,const Frame& rhs)
      |                   [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:750:17:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector2 KDL::operator*(const KDL::Vector2&, double)[m[Kâ€™
  750 | IMETHOD Vector2 [01;36m[Koperator[m[K *(const Vector2& lhs,double rhs)
      |                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:750:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
  750 | IMETHOD Vector2 operator *([01;36m[Kconst Vector2& lhs[m[K,double rhs)
      |                            [01;36m[K~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:755:17:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector2 KDL::operator*(double, const KDL::Vector2&)[m[Kâ€™
  755 | IMETHOD Vector2 [01;36m[Koperator[m[K *(double lhs,const Vector2& rhs)
      |                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:755:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  755 | IMETHOD Vector2 operator *([01;36m[Kdouble lhs[m[K,const Vector2& rhs)
      |                            [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:863:19:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rotation2 KDL::operator*(const KDL::Rotation2&, const KDL::Rotation2&)[m[Kâ€™
  863 | IMETHOD Rotation2 [01;36m[Koperator[m[K *(const Rotation2& lhs,const Rotation2& rhs) {
      |                   [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:863:47:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  863 | IMETHOD Rotation2 operator *([01;36m[Kconst Rotation2& lhs[m[K,const Rotation2& rhs) {
      |                              [01;36m[K~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:923:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Frame2 KDL::operator*(const KDL::Frame2&, const KDL::Frame2&)[m[Kâ€™
  923 | IMETHOD Frame2 [01;36m[Koperator[m[K *(const Frame2& lhs,const Frame2& rhs)
      |                [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:923:41:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  923 | IMETHOD Frame2 operator *([01;36m[Kconst Frame2& lhs[m[K,const Frame2& rhs)
      |                           [01;36m[K~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:68:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationalInertia KDL::operator*(double, const KDL::RotationalInertia&)[m[Kâ€™
   68 |     RotationalInertia [01;36m[Koperator[m[K*(double a, const RotationalInertia& I);
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/rotationalinertia.hpp:43:51:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
   43 |         friend RotationalInertia operator*([01;36m[Kdouble a[m[K, const RotationalInertia& I);
      |                                            [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rigidbodyinertia.hpp:103:22:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RigidBodyInertia KDL::operator*(double, const KDL::RigidBodyInertia&)[m[Kâ€™
  103 |     RigidBodyInertia [01;36m[Koperator[m[K*(double a,const RigidBodyInertia& I);
      |                      [01;36m[K^~~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:55:50:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
   55 |         friend RigidBodyInertia operator*([01;36m[Kdouble a[m[K,const RigidBodyInertia& I);
      |                                           [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rigidbodyinertia.hpp:115:12:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator*(const KDL::RigidBodyInertia&, const KDL::Twist&)[m[Kâ€™
  115 |     Wrench [01;36m[Koperator[m[K*(const RigidBodyInertia& I,const Twist& t);
      |            [01;36m[K^~~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:59:57:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::RigidBodyInertia&[m[Kâ€™
   59 |         friend Wrench operator*([01;36m[Kconst RigidBodyInertia& I[m[K,const Twist& t);
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rigidbodyinertia.hpp:120:22:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RigidBodyInertia KDL::operator*(const KDL::Frame&, const KDL::RigidBodyInertia&)[m[Kâ€™
  120 |     RigidBodyInertia [01;36m[Koperator[m[K*(const Frame& T,const RigidBodyInertia& I);
      |                      [01;36m[K^~~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:61:56:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
   61 |         friend RigidBodyInertia operator*([01;36m[Kconst Frame& T[m[K,const RigidBodyInertia& I);
      |                                           [01;36m[K~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rigidbodyinertia.hpp:125:22:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RigidBodyInertia KDL::operator*(const KDL::Rotation&, const KDL::RigidBodyInertia&)[m[Kâ€™
  125 |     RigidBodyInertia [01;36m[Koperator[m[K*(const Rotation& R,const RigidBodyInertia& I);
      |                      [01;36m[K^~~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:63:59:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
   63 |         friend RigidBodyInertia operator*([01;36m[Kconst Rotation& R[m[K,const RigidBodyInertia& I);
      |                                           [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/chaindynparam.hpp:26[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:16[m[K:
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:97:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::ArticulatedBodyInertia KDL::operator*(double, const KDL::ArticulatedBodyInertia&)[m[Kâ€™
   97 |     ArticulatedBodyInertia [01;36m[Koperator[m[K*(double a,const ArticulatedBodyInertia& I);
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:72:56:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
   72 |         friend ArticulatedBodyInertia operator*([01;36m[Kdouble a[m[K,const ArticulatedBodyInertia& I);
      |                                                 [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:112:12:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator*(const KDL::ArticulatedBodyInertia&, const KDL::Twist&)[m[Kâ€™
  112 |     Wrench [01;36m[Koperator[m[K*(const ArticulatedBodyInertia& I,const Twist& t);
      |            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:77:63:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::ArticulatedBodyInertia&[m[Kâ€™
   77 |         friend Wrench operator*([01;36m[Kconst ArticulatedBodyInertia& I[m[K,const Twist& t);
      |                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:117:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::ArticulatedBodyInertia KDL::operator*(const KDL::Frame&, const KDL::ArticulatedBodyInertia&)[m[Kâ€™
  117 |     ArticulatedBodyInertia [01;36m[Koperator[m[K*(const Frame& T,const ArticulatedBodyInertia& I);
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:78:62:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
   78 |         friend ArticulatedBodyInertia operator*([01;36m[Kconst Frame& T[m[K,const ArticulatedBodyInertia& I);
      |                                                 [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:122:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::ArticulatedBodyInertia KDL::operator*(const KDL::Rotation&, const KDL::ArticulatedBodyInertia&)[m[Kâ€™
  122 |     ArticulatedBodyInertia [01;36m[Koperator[m[K*(const Rotation& R,const ArticulatedBodyInertia& I);
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:79:65:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
   79 |         friend ArticulatedBodyInertia operator*([01;36m[Kconst Rotation& R[m[K,const ArticulatedBodyInertia& I);
      |                                                 [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:223:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator*(const KDL::Rall1d<T, V, S>&, const KDL::Rall1d<T, V, S>&)[m[Kâ€™
  223 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K *(const Rall1d<T,V,S>& lhs,const Rall1d<T,V,S>& rhs)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:223:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Jacobian[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:248:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator*(S, const KDL::Rall1d<T, V, S>&)[m[Kâ€™
  248 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K *(S s,const Rall1d<T,V,S>& v)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:248:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:254:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator*(const KDL::Rall1d<T, V, S>&, S)[m[Kâ€™
  254 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K *(const Rall1d<T,V,S>& v,S s)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:254:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Jacobian[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/framevel.inl:33:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameVel KDL::operator*(const KDL::FrameVel&, const KDL::FrameVel&)[m[Kâ€™
   33 | FrameVel [01;36m[Koperator[m[K *(const FrameVel& lhs,const FrameVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:33:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::FrameVel&[m[Kâ€™
   33 | FrameVel operator *([01;36m[Kconst FrameVel& lhs[m[K,const FrameVel& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:37:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameVel KDL::operator*(const KDL::FrameVel&, const KDL::Frame&)[m[Kâ€™
   37 | FrameVel [01;36m[Koperator[m[K *(const FrameVel& lhs,const Frame& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:37:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::FrameVel&[m[Kâ€™
   37 | FrameVel operator *([01;36m[Kconst FrameVel& lhs[m[K,const Frame& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:41:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameVel KDL::operator*(const KDL::Frame&, const KDL::FrameVel&)[m[Kâ€™
   41 | FrameVel [01;36m[Koperator[m[K *(const Frame& lhs,const FrameVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:41:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
   41 | FrameVel operator *([01;36m[Kconst Frame& lhs[m[K,const FrameVel& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:94:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationVel KDL::operator*(const KDL::RotationVel&, const KDL::RotationVel&)[m[Kâ€™
   94 | RotationVel [01;36m[Koperator[m[K* (const RotationVel& r1,const RotationVel& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:94:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::RotationVel&[m[Kâ€™
   94 | RotationVel operator* ([01;36m[Kconst RotationVel& r1[m[K,const RotationVel& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:98:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationVel KDL::operator*(const KDL::Rotation&, const KDL::RotationVel&)[m[Kâ€™
   98 | RotationVel [01;36m[Koperator[m[K* (const Rotation& r1,const RotationVel& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:98:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
   98 | RotationVel operator* ([01;36m[Kconst Rotation& r1[m[K,const RotationVel& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:102:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationVel KDL::operator*(const KDL::RotationVel&, const KDL::Rotation&)[m[Kâ€™
  102 | RotationVel [01;36m[Koperator[m[K* (const RotationVel& r1,const Rotation& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:102:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::RotationVel&[m[Kâ€™
  102 | RotationVel operator* ([01;36m[Kconst RotationVel& r1[m[K,const Rotation& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:245:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::VectorVel&, const KDL::VectorVel&)[m[Kâ€™
  245 | VectorVel [01;36m[Koperator[m[K * (const VectorVel& r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:245:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  245 | VectorVel operator * ([01;36m[Kconst VectorVel& r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:249:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::VectorVel&, const KDL::Vector&)[m[Kâ€™
  249 | VectorVel [01;36m[Koperator[m[K * (const VectorVel& r1,const Vector& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:249:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  249 | VectorVel operator * ([01;36m[Kconst VectorVel& r1[m[K,const Vector& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:253:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::Vector&, const KDL::VectorVel&)[m[Kâ€™
  253 | VectorVel [01;36m[Koperator[m[K * (const Vector& r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:253:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
  253 | VectorVel operator * ([01;36m[Kconst Vector& r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:260:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(double, const KDL::VectorVel&)[m[Kâ€™
  260 | VectorVel [01;36m[Koperator[m[K * (double r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:260:30:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  260 | VectorVel operator * ([01;36m[Kdouble r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:264:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::VectorVel&, double)[m[Kâ€™
  264 | VectorVel [01;36m[Koperator[m[K * (const VectorVel& r1,double r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:264:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  264 | VectorVel operator * ([01;36m[Kconst VectorVel& r1[m[K,double r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:270:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const doubleVel&, const KDL::VectorVel&)[m[Kâ€™
  270 | VectorVel [01;36m[Koperator[m[K * (const doubleVel& r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:270:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst doubleVel&[m[Kâ€™ {aka â€˜[01m[Kconst KDL::Rall1d<double>&[m[Kâ€™}
  270 | VectorVel operator * ([01;36m[Kconst doubleVel& r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:274:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::VectorVel&, const doubleVel&)[m[Kâ€™
  274 | VectorVel [01;36m[Koperator[m[K * (const VectorVel& r2,const doubleVel& r1) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:274:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  274 | VectorVel operator * ([01;36m[Kconst VectorVel& r2[m[K,const doubleVel& r1) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:286:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator*(const KDL::Rotation&, const KDL::VectorVel&)[m[Kâ€™
  286 | VectorVel [01;36m[Koperator[m[K*(const Rotation& R,const VectorVel& x) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:286:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  286 | VectorVel operator*([01;36m[Kconst Rotation& R[m[K,const VectorVel& x) {
      |                     [01;36m[K~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/framevel.inl:415:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistVel KDL::operator*(const KDL::TwistVel&, double)[m[Kâ€™
  415 | TwistVel [01;36m[Koperator[m[K*(const TwistVel& lhs,double rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:415:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistVel&[m[Kâ€™
  415 | TwistVel operator*([01;36m[Kconst TwistVel& lhs[m[K,double rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:420:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistVel KDL::operator*(double, const KDL::TwistVel&)[m[Kâ€™
  420 | TwistVel [01;36m[Koperator[m[K*(double lhs,const TwistVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:420:27:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  420 | TwistVel operator*([01;36m[Kdouble lhs[m[K,const TwistVel& rhs)
      |                    [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:431:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistVel KDL::operator*(const KDL::TwistVel&, const doubleVel&)[m[Kâ€™
  431 | TwistVel [01;36m[Koperator[m[K*(const TwistVel& lhs,const doubleVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:431:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistVel&[m[Kâ€™
  431 | TwistVel operator*([01;36m[Kconst TwistVel& lhs[m[K,const doubleVel& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/framevel.inl:436:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistVel KDL::operator*(const doubleVel&, const KDL::TwistVel&)[m[Kâ€™
  436 | TwistVel [01;36m[Koperator[m[K*(const doubleVel& lhs,const TwistVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:436:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst doubleVel&[m[Kâ€™ {aka â€˜[01m[Kconst KDL::Rall1d<double>&[m[Kâ€™}
  436 | TwistVel operator*([01;36m[Kconst doubleVel& lhs[m[K,const TwistVel& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:236:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator*(const KDL::Rall2d<T, V, S>&, const KDL::Rall2d<T, V, S>&)[m[Kâ€™
  236 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K *(const Rall2d<T,V,S>& lhs,const Rall2d<T,V,S>& rhs)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:236:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Jacobian[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:264:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator*(S, const KDL::Rall2d<T, V, S>&)[m[Kâ€™
  264 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K *(S s,const Rall2d<T,V,S>& v)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:264:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:270:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator*(const KDL::Rall2d<T, V, S>&, S)[m[Kâ€™
  270 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K *(const Rall2d<T,V,S>& v,S s)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:270:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:326:25:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Jacobian[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  326 |             Vd_ = Jd_ * [01;36m[Kqd_dot_[m[K;
      |                         [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:267[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/frameacc.inl:52:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::VectorAcc&, const KDL::VectorAcc&)[m[Kâ€™
   52 | VectorAcc [01;36m[Koperator[m[K * (const VectorAcc& r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:52:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   52 | VectorAcc operator * ([01;36m[Kconst VectorAcc& r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:59:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::VectorAcc&, const KDL::Vector&)[m[Kâ€™
   59 | VectorAcc [01;36m[Koperator[m[K * (const VectorAcc& r1,const Vector& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:59:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   59 | VectorAcc operator * ([01;36m[Kconst VectorAcc& r1[m[K,const Vector& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:63:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::Vector&, const KDL::VectorAcc&)[m[Kâ€™
   63 | VectorAcc [01;36m[Koperator[m[K * (const Vector& r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:63:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
   63 | VectorAcc operator * ([01;36m[Kconst Vector& r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:70:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(double, const KDL::VectorAcc&)[m[Kâ€™
   70 | VectorAcc [01;36m[Koperator[m[K * (double r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:70:30:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
   70 | VectorAcc operator * ([01;36m[Kdouble r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:74:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::VectorAcc&, double)[m[Kâ€™
   74 | VectorAcc [01;36m[Koperator[m[K * (const VectorAcc& r1,double r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:74:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   74 | VectorAcc operator * ([01;36m[Kconst VectorAcc& r1[m[K,double r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:78:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const doubleAcc&, const KDL::VectorAcc&)[m[Kâ€™
   78 | VectorAcc [01;36m[Koperator[m[K * (const doubleAcc& r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:78:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst doubleAcc&[m[Kâ€™ {aka â€˜[01m[Kconst KDL::Rall2d<double, double, double>&[m[Kâ€™}
   78 | VectorAcc operator * ([01;36m[Kconst doubleAcc& r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:85:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::VectorAcc&, const doubleAcc&)[m[Kâ€™
   85 | VectorAcc [01;36m[Koperator[m[K * (const VectorAcc& r2,const doubleAcc& r1) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:85:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   85 | VectorAcc operator * ([01;36m[Kconst VectorAcc& r2[m[K,const doubleAcc& r1) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:192:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationAcc KDL::operator*(const KDL::RotationAcc&, const KDL::RotationAcc&)[m[Kâ€™
  192 | RotationAcc [01;36m[Koperator[m[K* (const RotationAcc& r1,const RotationAcc& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:192:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::RotationAcc&[m[Kâ€™
  192 | RotationAcc operator* ([01;36m[Kconst RotationAcc& r1[m[K,const RotationAcc& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:199:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationAcc KDL::operator*(const KDL::Rotation&, const KDL::RotationAcc&)[m[Kâ€™
  199 | RotationAcc [01;36m[Koperator[m[K* (const Rotation& r1,const RotationAcc& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:199:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  199 | RotationAcc operator* ([01;36m[Kconst Rotation& r1[m[K,const RotationAcc& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:203:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationAcc KDL::operator*(const KDL::RotationAcc&, const KDL::Rotation&)[m[Kâ€™
  203 | RotationAcc [01;36m[Koperator[m[K* (const RotationAcc& r1,const Rotation& r2) {
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:203:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::RotationAcc&[m[Kâ€™
  203 | RotationAcc operator* ([01;36m[Kconst RotationAcc& r1[m[K,const Rotation& r2) {
      |                        [01;36m[K~~~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:254:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator*(const KDL::Rotation&, const KDL::VectorAcc&)[m[Kâ€™
  254 | VectorAcc [01;36m[Koperator[m[K*(const Rotation& R,const VectorAcc& x) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:254:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  254 | VectorAcc operator*([01;36m[Kconst Rotation& R[m[K,const VectorAcc& x) {
      |                     [01;36m[K~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frameacc.inl:349:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameAcc KDL::operator*(const KDL::FrameAcc&, const KDL::FrameAcc&)[m[Kâ€™
  349 | FrameAcc [01;36m[Koperator[m[K *(const FrameAcc& lhs,const FrameAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:349:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::FrameAcc&[m[Kâ€™
  349 | FrameAcc operator *([01;36m[Kconst FrameAcc& lhs[m[K,const FrameAcc& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:353:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameAcc KDL::operator*(const KDL::FrameAcc&, const KDL::Frame&)[m[Kâ€™
  353 | FrameAcc [01;36m[Koperator[m[K *(const FrameAcc& lhs,const Frame& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:353:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::FrameAcc&[m[Kâ€™
  353 | FrameAcc operator *([01;36m[Kconst FrameAcc& lhs[m[K,const Frame& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:357:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::FrameAcc KDL::operator*(const KDL::Frame&, const KDL::FrameAcc&)[m[Kâ€™
  357 | FrameAcc [01;36m[Koperator[m[K *(const Frame& lhs,const FrameAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:357:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
  357 | FrameAcc operator *([01;36m[Kconst Frame& lhs[m[K,const FrameAcc& rhs)
      |                     [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:471:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistAcc KDL::operator*(const KDL::TwistAcc&, double)[m[Kâ€™
  471 | TwistAcc [01;36m[Koperator[m[K*(const TwistAcc& lhs,double rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:471:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistAcc&[m[Kâ€™
  471 | TwistAcc operator*([01;36m[Kconst TwistAcc& lhs[m[K,double rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:476:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistAcc KDL::operator*(double, const KDL::TwistAcc&)[m[Kâ€™
  476 | TwistAcc [01;36m[Koperator[m[K*(double lhs,const TwistAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:476:27:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™
  476 | TwistAcc operator*([01;36m[Kdouble lhs[m[K,const TwistAcc& rhs)
      |                    [01;36m[K~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:487:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistAcc KDL::operator*(const KDL::TwistAcc&, const doubleAcc&)[m[Kâ€™
  487 | TwistAcc [01;36m[Koperator[m[K*(const TwistAcc& lhs,const doubleAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:487:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistAcc&[m[Kâ€™
  487 | TwistAcc operator*([01;36m[Kconst TwistAcc& lhs[m[K,const doubleAcc& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:492:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistAcc KDL::operator*(const doubleAcc&, const KDL::TwistAcc&)[m[Kâ€™
  492 | TwistAcc [01;36m[Koperator[m[K*(const doubleAcc& lhs,const TwistAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:492:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::Jacobian[m[Kâ€™ to â€˜[01m[Kconst doubleAcc&[m[Kâ€™ {aka â€˜[01m[Kconst KDL::Rall2d<double, double, double>&[m[Kâ€™}
  492 | TwistAcc operator*([01;36m[Kconst doubleAcc& lhs[m[K,const TwistAcc& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:366[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainjnttojacsolver.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h: In instantiation of â€˜[01m[Kconst Eigen::Product<Derived, OtherDerived> Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Derived = Eigen::Matrix<double, -1, 1>][m[Kâ€™:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:306:66:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h:406:3:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS
  406 |   [01;31m[KEIGEN_STATIC_ASSERT[m[K(ProductIsValid || !(AreVectors && SameSizes),
      |   [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h: In instantiation of â€˜[01m[Kconst Eigen::Product<Derived, OtherDerived, 1> Eigen::MatrixBase<Derived>::lazyProduct(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Derived = Eigen::Matrix<double, -1, 1>][m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:404:29:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::addTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Lhs = Eigen::Matrix<double, -1, 1>; Rhs = Eigen::Matrix<double, 6, 1, 0, 6, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:163:42:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::add_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == Eigen::DefaultProduct) || (Options == Eigen::AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::add_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Lhs = Eigen::Matrix<double, -1, 1>; Rhs = Eigen::Matrix<double, 6, 1, 0, 6, 1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::add_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == Eigen::DefaultProduct) || (Options == Eigen::AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Src = Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0>; Func = Eigen::internal::add_assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/ProductEvaluators.h:224:29:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::assignment_from_xpr_op_product<DstXprType, OtherXpr, ProductType, Func1, Func2>::run(DstXprType&, const SrcXprType&, const InitialFunc&) [with SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >; InitialFunc = Eigen::internal::assign_op<double, double>; DstXprType = Eigen::Matrix<double, 6, 1, 0, 6, 1>; OtherXpr = Eigen::Matrix<double, 6, 1, 0, 6, 1>; ProductType = Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0>; Func1 = Eigen::internal::assign_op<double, double>; Func2 = Eigen::internal::add_assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 6, 1, 0, 6, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >; Func = Eigen::internal::assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:732:41:[m[K   [ skipping 19 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:836:49:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >; Func = Eigen::internal::assign_op<double, double>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:804:27:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/AssignEvaluator.h:782:18:[m[K   required from â€˜[01m[Kvoid Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:714:32:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >; Derived = Eigen::Matrix<double, -1, 1>][m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:225:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, 6, 1, 0, 6, 1>, const Eigen::Product<Eigen::Matrix<double, -1, 1>, Eigen::Matrix<double, 6, 1, 0, 6, 1>, 0> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1][m[Kâ€™
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:306:73:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/GeneralProduct.h:444:3:[m[K [01;31m[Kerror: [m[Kstatic assertion failed: INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS
  444 |   [01;31m[KEIGEN_STATIC_ASSERT[m[K(ProductIsValid || !(AreVectors && SameSizes),
      |   [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
make[2]: *** [CMakeFiles/arm_controllers.dir/build.make:141: CMakeFiles/arm_controllers.dir/src/velocity_controller.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:385: CMakeFiles/arm_controllers.dir/all] Error 2
make: *** [Makefile:141: all] Error 2
