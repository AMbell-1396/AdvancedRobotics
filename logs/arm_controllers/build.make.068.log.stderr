[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:595:16:[m[K [01;31m[Kerror: [m[Kredeclaration of â€˜[01m[KKDL::Twist arm_controllers::velocity_controller::Vd_[m[Kâ€™
  595 |     KDL::Twist [01;31m[KVd_[m[K;
      |                [01;31m[K^~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:584:19:[m[K [01;36m[Knote: [m[Kprevious declaration â€˜[01m[KKDL::JntArray arm_controllers::velocity_controller::Vd_[m[Kâ€™
  584 |     KDL::JntArray [01;36m[KVd_[m[K;
      |                   [01;36m[K^~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:[m[K In member function â€˜[01m[Kvirtual void arm_controllers::velocity_controller::update(const ros::Time&, const ros::Duration&)[m[Kâ€™:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:308:16:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator[][m[Kâ€™ (operand types are â€˜[01m[KKDL::JntArray[m[Kâ€™ and â€˜[01m[Ksize_t[m[Kâ€™ {aka â€˜[01m[Klong unsigned int[m[Kâ€™})
  308 |             Vd_[01;31m[K[[m[Ki] = Vd_jnt_.data[i];
      |                [01;31m[K^[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:25:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator+[m[Kâ€™ (operand types are â€˜[01m[KKDL::JntArray[m[Kâ€™ and â€˜[01m[KKDL::Twist[m[Kâ€™)
  345 |             Vcmd_ = [32m[KVd_[m[K [01;31m[K+[m[K [34m[K1.0*Xerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                     [32m[K~~~[m[K [01;31m[K^[m[K [34m[K~~~~~~~~~[m[K
      |                     [32m[K|[m[K        [34m[K|[m[K
      |                     [32m[K|[m[K        [34m[KKDL::Twist[m[K
      |                     [32m[KKDL::JntArray[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/frames.inl:57:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector KDL::operator+(const KDL::Vector&, const KDL::Vector&)[m[Kâ€™
   57 | IMETHOD Vector [01;36m[Koperator[m[K +(const Vector & lhs,const Vector& rhs)
      |                [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:57:42:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
   57 | IMETHOD Vector operator +([01;36m[Kconst Vector & lhs[m[K,const Vector& rhs)
      |                           [01;36m[K~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:258:8:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Wrench KDL::operator+(const KDL::Wrench&, const KDL::Wrench&)[m[Kâ€™
  258 | Wrench [01;36m[Koperator[m[K+(const Wrench& lhs,const Wrench& rhs)
      |        [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:258:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
  258 | Wrench operator+([01;36m[Kconst Wrench& lhs[m[K,const Wrench& rhs)
      |                  [01;36m[K~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:361:7:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Twist KDL::operator+(const KDL::Twist&, const KDL::Twist&)[m[Kâ€™
  361 | Twist [01;36m[Koperator[m[K+(const Twist& lhs,const Twist& rhs)
      |       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:361:30:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  361 | Twist operator+([01;36m[Kconst Twist& lhs[m[K,const Twist& rhs)
      |                 [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/kdl/frames.inl:740:17:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Vector2 KDL::operator+(const KDL::Vector2&, const KDL::Vector2&)[m[Kâ€™
  740 | IMETHOD Vector2 [01;36m[Koperator[m[K +(const Vector2 & lhs,const Vector2& rhs)
      |                 [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:740:44:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
  740 | IMETHOD Vector2 operator +([01;36m[Kconst Vector2 & lhs[m[K,const Vector2& rhs)
      |                            [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:69:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RotationalInertia KDL::operator+(const KDL::RotationalInertia&, const KDL::RotationalInertia&)[m[Kâ€™
   69 |     RotationalInertia [01;36m[Koperator[m[K+(const RotationalInertia& Ia, const RotationalInertia& Ib);
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/rotationalinertia.hpp:44:69:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::RotationalInertia&[m[Kâ€™
   44 |         friend RotationalInertia operator+([01;36m[Kconst RotationalInertia& Ia[m[K, const RotationalInertia& Ib);
      |                                            [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~^~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rigidbodyinertia.hpp:109:22:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::RigidBodyInertia KDL::operator+(const KDL::RigidBodyInertia&, const KDL::RigidBodyInertia&)[m[Kâ€™
  109 |     RigidBodyInertia [01;36m[Koperator[m[K+(const RigidBodyInertia& Ia,const RigidBodyInertia& Ib);
      |                      [01;36m[K^~~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/rigidbodyinertia.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/tree.hpp:27[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:11[m[K:
[01m[K/usr/include/kdl/rotationalinertia.hpp:57:67:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::RigidBodyInertia&[m[Kâ€™
   57 |         friend RigidBodyInertia operator+([01;36m[Kconst RigidBodyInertia& Ia[m[K,const RigidBodyInertia& Ib);
      |                                           [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^~[m[K
In file included from [01m[K/usr/include/kdl/chaindynparam.hpp:26[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:103:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::ArticulatedBodyInertia KDL::operator+(const KDL::ArticulatedBodyInertia&, const KDL::ArticulatedBodyInertia&)[m[Kâ€™
  103 |     ArticulatedBodyInertia [01;36m[Koperator[m[K+(const ArticulatedBodyInertia& Ia,const ArticulatedBodyInertia& Ib);
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:73:79:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::ArticulatedBodyInertia&[m[Kâ€™
   73 |         friend ArticulatedBodyInertia operator+([01;36m[Kconst ArticulatedBodyInertia& Ia[m[K,const ArticulatedBodyInertia& Ib);
      |                                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:104:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::ArticulatedBodyInertia KDL::operator+(const KDL::ArticulatedBodyInertia&, const KDL::RigidBodyInertia&)[m[Kâ€™
  104 |     ArticulatedBodyInertia [01;36m[Koperator[m[K+(const ArticulatedBodyInertia& Ia,const RigidBodyInertia& Ib);
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/articulatedbodyinertia.hpp:74:79:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::ArticulatedBodyInertia&[m[Kâ€™
   74 |         friend ArticulatedBodyInertia operator+([01;36m[Kconst ArticulatedBodyInertia& Ia[m[K,const RigidBodyInertia& Ib);
      |                                                 [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:229:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator+(const KDL::Rall1d<T, V, S>&, const KDL::Rall1d<T, V, S>&)[m[Kâ€™
  229 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K +(const Rall1d<T,V,S>& lhs,const Rall1d<T,V,S>& rhs)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:229:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:260:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator+(S, const KDL::Rall1d<T, V, S>&)[m[Kâ€™
  260 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K +(S s,const Rall1d<T,V,S>& v)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:260:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Twist[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:266:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall1d<T, V, S> KDL::operator+(const KDL::Rall1d<T, V, S>&, S)[m[Kâ€™
  266 | INLINE  Rall1d<T,V,S> [01;36m[Koperator[m[K +(const Rall1d<T,V,S>& v,S s)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:266:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall1d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/framevel.inl:210:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator+(const KDL::VectorVel&, const KDL::VectorVel&)[m[Kâ€™
  210 | VectorVel [01;36m[Koperator[m[K + (const VectorVel& r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:210:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  210 | VectorVel operator + ([01;36m[Kconst VectorVel& r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:218:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator+(const KDL::VectorVel&, const KDL::Vector&)[m[Kâ€™
  218 | VectorVel [01;36m[Koperator[m[K + (const VectorVel& r1,const Vector& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:218:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorVel&[m[Kâ€™
  218 | VectorVel operator + ([01;36m[Kconst VectorVel& r1[m[K,const Vector& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:226:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorVel KDL::operator+(const KDL::Vector&, const KDL::VectorVel&)[m[Kâ€™
  226 | VectorVel [01;36m[Koperator[m[K + (const Vector& r1,const VectorVel& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:226:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
  226 | VectorVel operator + ([01;36m[Kconst Vector& r1[m[K,const VectorVel& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/framevel.inl:449:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistVel KDL::operator+(const KDL::TwistVel&, const KDL::TwistVel&)[m[Kâ€™
  449 | TwistVel [01;36m[Koperator[m[K+(const TwistVel& lhs,const TwistVel& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.inl:449:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistVel&[m[Kâ€™
  449 | TwistVel operator+([01;36m[Kconst TwistVel& lhs[m[K,const TwistVel& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:246:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator+(const KDL::Rall2d<T, V, S>&, const KDL::Rall2d<T, V, S>&)[m[Kâ€™
  246 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K +(const Rall2d<T,V,S>& lhs,const Rall2d<T,V,S>& rhs)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:246:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:276:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator+(S, const KDL::Rall2d<T, V, S>&)[m[Kâ€™
  276 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K +(S s,const Rall2d<T,V,S>& v)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:276:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::Twist[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:282:23:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class V, class S> KDL::Rall2d<T, V, S> KDL::operator+(const KDL::Rall2d<T, V, S>&, S)[m[Kâ€™
  282 | INLINE  Rall2d<T,V,S> [01;36m[Koperator[m[K +(const Rall2d<T,V,S>& v,S s)
      |                       [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:282:23:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:345:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[KKDL::JntArray[m[Kâ€™ is not derived from â€˜[01m[Kconst KDL::Rall2d<T, V, S>[m[Kâ€™
  345 |             Vcmd_ = Vd_ + 1.0*[01;36m[KXerr_[m[K;  // replace gain = 1.0 with a matrix?
      |                               [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:267[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:17[m[K:
[01m[K/usr/include/kdl/frameacc.inl:24:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator+(const KDL::VectorAcc&, const KDL::VectorAcc&)[m[Kâ€™
   24 | VectorAcc [01;36m[Koperator[m[K + (const VectorAcc& r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:24:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   24 | VectorAcc operator + ([01;36m[Kconst VectorAcc& r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:31:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator+(const KDL::Vector&, const KDL::VectorAcc&)[m[Kâ€™
   31 | VectorAcc [01;36m[Koperator[m[K + (const Vector& r1,const VectorAcc& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:31:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
   31 | VectorAcc operator + ([01;36m[Kconst Vector& r1[m[K,const VectorAcc& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:38:11:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::VectorAcc KDL::operator+(const KDL::VectorAcc&, const KDL::Vector&)[m[Kâ€™
   38 | VectorAcc [01;36m[Koperator[m[K + (const VectorAcc& r1,const Vector& r2) {
      |           [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:38:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::VectorAcc&[m[Kâ€™
   38 | VectorAcc operator + ([01;36m[Kconst VectorAcc& r1[m[K,const Vector& r2) {
      |                       [01;36m[K~~~~~~~~~~~~~~~~~^~[m[K
[01m[K/usr/include/kdl/frameacc.inl:505:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::TwistAcc KDL::operator+(const KDL::TwistAcc&, const KDL::TwistAcc&)[m[Kâ€™
  505 | TwistAcc [01;36m[Koperator[m[K+(const TwistAcc& lhs,const TwistAcc& rhs)
      |          [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.inl:505:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[KKDL::JntArray[m[Kâ€™ to â€˜[01m[Kconst KDL::TwistAcc&[m[Kâ€™
  505 | TwistAcc operator+([01;36m[Kconst TwistAcc& lhs[m[K,const TwistAcc& rhs)
      |                    [01;36m[K~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:354:24:[m[K [01;31m[Kerror: [m[Kinvalid use of member function â€˜[01m[KEigen::PlainObjectBase<Derived>::Scalar* Eigen::PlainObjectBase<Derived>::data() [with Derived = Eigen::Matrix<double, -1, -1>; Eigen::PlainObjectBase<Derived>::Scalar = double][m[Kâ€™ (did you forget the â€˜[01m[K()[m[Kâ€™ ?)
  354 |                 [01;31m[KJ_inv_.data[m[K = J_.data.inverse();
      |                 [01;31m[K~~~~~~~^~~~[m[K
      |                            [32m[K()[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:43:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator*[m[Kâ€™ (operand types are â€˜[01m[K<unresolved overloaded function type>[m[Kâ€™ and â€˜[01m[KEigen::VectorXd[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<double, -1, 1>[m[Kâ€™})
  357 |             q_dot_cmd_.data = [32m[KJ_inv_.data[m[K [01;31m[K*[m[K [34m[KVcmd_jnt_.data[m[K;
      |                               [32m[K~~~~~~~~~~~[m[K [01;31m[K^[m[K [34m[K~~~~~~~~~~~~~~[m[K
      |                                      [32m[K|[m[K                [34m[K|[m[K
      |                                      [32m[K|[m[K                [34m[KEigen::VectorXd {aka Eigen::Matrix<double, -1, 1>}[m[K
      |                                      [32m[K<unresolved overloaded function type>[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:487[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:543:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class PermutationDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::operator*(const Eigen::MatrixBase<Derived>&, const Eigen::PermutationBase<PermutationDerived>&)[m[Kâ€™
  543 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:543:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[KEigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™ {aka â€˜[01m[Kdouble* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™}
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[Kconst Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™ {aka â€˜[01m[Kconst double* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™}
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::VectorXd[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<double, -1, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Core:487[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:555:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class PermutationDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::operator*(const Eigen::PermutationBase<PermutationDerived>&, const Eigen::MatrixBase<U>&)[m[Kâ€™
  555 | [01;36m[Koperator[m[K*(const PermutationBase<PermutationDerived> &permutation,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:555:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™ and â€˜[01m[KEigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™ {aka â€˜[01m[Kdouble* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™}
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™ and â€˜[01m[Kconst Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™ {aka â€˜[01m[Kconst double* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™}
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  couldnâ€™t deduce template parameter â€˜[01m[KPermutationDerived[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Core:488[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:338:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class TranspositionsDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::operator*(const Eigen::MatrixBase<Derived>&, const Eigen::TranspositionsBase<TranspositionsDerived>&)[m[Kâ€™
  338 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:338:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[KEigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™ {aka â€˜[01m[Kdouble* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™}
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[Kconst Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™ {aka â€˜[01m[Kconst double* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™}
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::VectorXd[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<double, -1, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Core:488[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:350:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class TranspositionsDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::operator*(const Eigen::TranspositionsBase<TranspositionsDerived>&, const Eigen::MatrixBase<U>&)[m[Kâ€™
  350 | [01;36m[Koperator[m[K*(const TranspositionsBase<TranspositionsDerived> &transpositions,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:350:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™ and â€˜[01m[KEigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™ {aka â€˜[01m[Kdouble* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™}
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™ and â€˜[01m[Kconst Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™ {aka â€˜[01m[Kconst double* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™}
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  couldnâ€™t deduce template parameter â€˜[01m[KTranspositionsDerived[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Householder:24[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/QR:17[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/SVD:11[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/include/utils/pseudo_inversion.h:10[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:24[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:438:99:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class OtherDerived, class VectorsType, class CoeffsType, int Side> typename Eigen::internal::matrix_type_times_scalar_type<typename VectorsType::Scalar, OtherDerived>::Type Eigen::operator*(const Eigen::MatrixBase<Derived>&, const Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>&)[m[Kâ€™
  438 | typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type [01;36m[Koperator[m[K*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
      |                                                                                                   [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:438:99:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[KEigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™ {aka â€˜[01m[Kdouble* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)()[m[Kâ€™}
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  mismatched types â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™ and â€˜[01m[Kconst Scalar* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™ {aka â€˜[01m[Kconst double* (Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1> >::*)() const[m[Kâ€™}
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  â€˜[01m[KEigen::VectorXd[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<double, -1, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Core:88[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> typename Eigen::internal::enable_if<true, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<double, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, double, Eigen::internal::scalar_product_op<T, double> > >::value>::type, double>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<double, -1, 1>, typename Eigen::internal::promote_scalar_arg<double, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, double, Eigen::internal::scalar_product_op<T, double> > >::value>::type>::type, const Eigen::Matrix<double, -1, 1> > >::type Eigen::operator*(const T&, const StorageBaseType&)[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  couldnâ€™t deduce template parameter â€˜[01m[KT[m[Kâ€™
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:88[m[K,
                 from [01m[K/usr/include/kdl/jacobian.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:15[m[K:
[01m[K/usr/include/eigen3/Eigen/src/plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> typename Eigen::internal::enable_if<true, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<double, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, double, Eigen::internal::scalar_product_op<T, double> > >::value>::type, double>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<double, -1, -1>, typename Eigen::internal::promote_scalar_arg<double, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, double, Eigen::internal::scalar_product_op<T, double> > >::value>::type>::type, const Eigen::Matrix<double, -1, -1> > >::type Eigen::operator*(const T&, const StorageBaseType&)[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/advrob/elfin_ws/src/edu-elfin_simulation/arm_controllers/src/velocity_controller.cpp:357:55:[m[K [01;36m[Knote: [m[K  couldnâ€™t deduce template parameter â€˜[01m[KT[m[Kâ€™
  357 |             q_dot_cmd_.data = J_inv_.data * Vcmd_jnt_.[01;36m[Kdata[m[K;
      |                                                       [01;36m[K^~~~[m[K
make[2]: *** [CMakeFiles/arm_controllers.dir/build.make:141: CMakeFiles/arm_controllers.dir/src/velocity_controller.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:385: CMakeFiles/arm_controllers.dir/all] Error 2
make: *** [Makefile:141: all] Error 2
